# 1、概述

## 1.Hystrix介绍

Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，Hystrix会保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性

断路器本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控，向调用方返回一个预期的、可处理的备选响应，而不是长时间的等待或者跑出调用方无法处理的异常

## 2.Hystrix主要功能

1. 服务降级
2. 服务熔断
3. 接近实时的监控

## 3.Hystrix重要概念

1. 服务降级：假设对方系统不可用了，会返回一个备选解决方案
2. 服务熔断：达到最大访问量之后，直接拒绝访问，然后调用服务降级的方法并返回友好提示
3. 服务限流：秒杀高并发等操作，让访问依次排队执行

# 2、服务端微服务构建

## 1.pom依赖

```xml
    <dependencies>
        <dependency>
            <groupId>com.he.springcloud</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
    </dependencies>
```

## 2.配置文件

```yml
server:
  port: 8001

spring:
  application:
    name: cloud-provider-hystrix-payment

eureka:
  client:
    register-with-eureka: true
    fetch-registry: true
    server-url:
      defaultZone: http://eureka7001.com:7001/eureka
```

## 3.主启动类

因为要注册进eureka，所有要在主启动类上加注解@EnableEurekaClient

## 4.业务类

```java
@Service
public class PaymentServiceImpl implements PaymentService {
    
    @Override
    public String paymentInfo_OK(int id) {
        return "线程池："+Thread.currentThread().getName()+"  paymentInfo_OK,id:"+id+"\t"+"。";
    }

    @Override
//    模拟超时
    public String paymentInfo_TimeOut(int id) {
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "线程池："+Thread.currentThread().getName()+"  paymentInfo_TimeOut,id:"+id+"\t"+"，耗时三秒钟。";
    }
}
```

## 5.控制类

```java
@RestController
@Slf4j
public class PaymentController {

    @Resource
    private PaymentService paymentService;

    @Value("${server.port}")
    private String SERVER_PORT;

    @GetMapping("/payment/hystrix/ok/{id}")
    public String paymentInfo_OK(@PathVariable("id") int id) {
        String result = paymentService.paymentInfo_OK(id);
        log.info("result:"+result);
        return result;
    }

    @GetMapping("/payment/hystrix/timeout/{id}")
    public String paymentInfo_TimeOut(@PathVariable("id") int id) {
        String result = paymentService.paymentInfo_TimeOut(id);
        log.info("result:"+result);
        return result;
    }

}
```

# 3、消费端微服务构建

## 1.pom依赖

```xml
    <dependencies>
         <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
        <dependency>
            <groupId>com.he.springcloud</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
    </dependencies>
```

## 2.配置文件

```yml
server:
  port: 80

spring:
  application:
    name: cloud-consumer-hystrix-order

eureka:
  client:
    register-with-eureka: true
    fetchRegistry: true
      service-url:
        defaultZone: http://eureka7001.com:7001/eure
```

## 3.主启动类

在类头上加@EnableFeignClients来搜索加了@FeignClient注解的业务类

```java
@SpringBootApplication
@EnableFeignClients
public class CloudConsumerHystrixOrder80Application {

    public static void main(String[] args) {
        SpringApplication.run(CloudConsumerHystrixOrder80Application.class, args);
    }

}
```

## 4.业务类

使用OpenFeign

```java
@Component
@FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT")
public interface PaymentHystrixService {

    @GetMapping(value = "/payment/hystrix/ok/{id}")
    public String paymentInfo_OK(@PathVariable("id") Integer id);

    @GetMapping(value = "/payment/hystrix/timeout/{id}")
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id);

}
```

## 5.控制类

```java
@RestController
@Slf4j
public class OrderHystrixController {

    @Resource
    private PaymentHystrixService paymentHystrixService;

    @GetMapping(value = "/consumer/payment/hystrix/ok/{id}")
    public String paymentInfo_OK(@PathVariable("id") Integer id){
        return paymentHystrixService.paymentInfo_OK(id);
    }

    @GetMapping(value = "/consumer/payment/hystrix/timeout/{id}")
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id){
        return paymentHystrixService.paymentInfo_TimeOut(id);
    }

}
```

# 4、使用JMeter高并发压力测试

##  1.新建线程组

![image-20201121154600303](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201121154600303.png)

## 2.新建http请求访问paymentInfo_TimeOut

![image-20201121154627475](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201121154627475.png)

## 3.结果

因为太多线程访问paymentInfo_TimeOut，导致服务端资源掏空，导致服务端对paymentInfo_OK的访问也被拖慢了

# 5、服务降级

服务降级一般都放在消费端处理

## 1.服务端修改

### 1.修改主启动类

主启动类上加@EnableCircuitBreaker来开启服务降级

```java
@SpringBootApplication
@EnableEurekaClient
//开启服务降级
@EnableCircuitBreaker
public class CloudProviderHystrixPayment8001Application {

    public static void main(String[] args) {
        SpringApplication.run(CloudProviderHystrixPayment8001Application.class, args);
    }

}
```

### 2.修改服务实现类

在需要监控的服务方法上加上@HystrixCommand注解fallbackMethod是用来指定备选方法，设置响应时间为3s内正常，但是方法要5s才执行响应完毕

```java
    @Override
//    模拟超时
//    当这个服务方法失败出错后，自动调用备选方法paymentInfo_TimeOutHandler
    @HystrixCommand(fallbackMethod = "paymentInfo_TimeOutHandler",commandProperties = {
//            设置在响应时间3s内算是正常，超过3s就会服务降级调用备用方法
            @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "3000")
    })
    public String paymentInfo_TimeOut(Integer id) {
        try {
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "线程池："+Thread.currentThread().getName()+"  paymentInfo_TimeOut,id:"+id+"\t"+"，耗时三秒钟。";
    }
```

备选方法

```java
    public String paymentInfo_TimeOutHandler(Integer id){
        return "线程池："+Thread.currentThread().getName()+"  paymentInfo_TimeOut,id:"+id+"\t"+"，服务超时。";
    }
```

### 3.效果

![image-20201121165639278](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201121165639278.png)

可以看到服务超时了，调用了备选方法，只要这个服务方法出错了，就会调用备选方法

## 2.消费端修改

### 1.修改yml

开启feign对hystrix的支持

```yml
#开启feign对hystrix的支持
feign:
  hystrix:
    enabled: true
```

### 2.主启动类

在主启动类上加@EnableHystrix来开启对Hystrix的支持

```java
@SpringBootApplication
@EnableFeignClients
//开启Hystrix
@EnableHystrix
public class CloudConsumerHystrixOrder80Application {

    public static void main(String[] args) {
        SpringApplication.run(CloudConsumerHystrixOrder80Application.class, args);
    }

}
```

### 3.修改控制类

消费端需要修改的是控制类方法，不是服务类方法

```java
    @GetMapping(value = "/consumer/payment/hystrix/timeout/{id}")
    //    当这个服务方法失败出错后，自动调用备选方法paymentInfo_TimeOutHandler
    @HystrixCommand(fallbackMethod = "paymentInfo_TimeOutFallbackMethod",commandProperties = {
//            设置在响应时间1.5s内算是正常，超过1.5s就会服务降级调用备用方法
            @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "1500")
    })
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id){
        return paymentHystrixService.paymentInfo_TimeOut(id);
    }

    public String paymentInfo_TimeOutFallbackMethod(@PathVariable("id") Integer id){
        return "这是80服务，支付服务繁忙，请10s后再试或80服务运行出错。";
    }
```

### 4.调用结果

![image-20201121172119566](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201121172119566.png)

服务端规定5s运行时间就没有出错，用了3s执行完了，但是消费端规定最多等待1.5s，所以会服务降级

## 3.全局服务降级

### 1.添加注解

在目标controller上加@DefaultProperties(defaultFallback = "payment_Global_FailbackMethod")后，这个controller类中标注了@HystrixCommand注解但是没有指定备用方法的服务方法，出现错误时就会去调用全局备用方法

### 2.全局备用方法

```java
//    全局备用方法
    public String payment_Global_FailbackMethod(){
        return "Global异常处理信息，请稍后重试";
    }
```

### 3.运行结果

![image-20201121174002672](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201121174002672.png)

标注了@HystrixCommand注解但是没有指定备用方法的服务方法，出现错误时调用了全局备用方法

## 4.通配服务降级

根据已有的业务类接口，重现新建一个类来实现该接口，统一为接口里的方法进行异常处理

### 1.修改yml

开启feign对hystrix的支持

```yml
#开启feign对hystrix的支持
feign:
  hystrix:
    enabled: true
```

### 2.新建业务实现类

注意要将这个实现类添加进spring容器

```java
@Component
public class PaymentFallbackService implements PaymentHystrixService{
    @Override
    public String paymentInfo_OK(Integer id) {
        return "PaymentFallbackService-paymentInfo_OK";
    }

    @Override
    public String paymentInfo_TimeOut(Integer id) {
        return "PaymentFallbackService-paymentInfo_TimeOut";
    }
}
```

### 3.修改业务类接口

将类上的接口添加fallback属性，值是业务实现类

```java
@FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT",fallback = PaymentFallbackService.class)
```

### 4.结果

当我们停掉服务端时，消费端再访问失败的时候，就会去调用与业务接口相对的业务实现类中同名的方法

![image-20201123160043402](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201123160043402.png)

# 6、服务熔断

## 1.熔断机制概述

熔断机制是应对雪崩效应的一种哦改为服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长的时候，会进行服务的降级，进而熔断该节点微服务的调用，快速放回错误的响应消息，**当检测到该节点微服务调用响应正常后，恢复调用链路**

## 2.修改服务端业务实现类

```java
//    服务熔断
    @HystrixCommand(fallbackMethod = "paymentCircuitBreaker_fallback",commandProperties = {
            @HystrixProperty(name = "circuitBreaker.enabled",value = "true"),  //是否开启断路器
            @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",value = "10"),  //请求次数
            @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",value = "10000"),   //时间窗口期
            @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",value = "60")     //失败率达到多少后跳闸
    })
    public String paymentCircuitBreaker(@PathVariable("id") Integer id){
        if (id < 0){
            throw new RuntimeException("*****id不能是负数");
        }
        String serialNummber = IdUtil.simpleUUID();
        return Thread.currentThread().getName()+"\t"+"调用成功，流水号"+serialNummber;
    }

    public String paymentCircuitBreaker_fallback(@PathVariable("id") Integer id){
        return "id 不能为负数，请稍后重试，id："+id;
    }
```

开启断路器后，在设定的窗口期时间内，10次请求的失败率达到60%（即10次请求失败6次）之后就会跳闸关闭服务，一旦在请求失败率降低了，就会重新开启服务

## 3.修改服务端控制类

只是在控制类调用一下服务方法，没有啥新东西

```java
@GetMapping("/payment/circuit/{id}")
public String paymentCircuitBreaker(@PathVariable("id") Integer id){
    String result = paymentService.paymentCircuitBreaker(id);
    log.info("result:"+result);
    return result;
}
```

## 4.演示结果

当id为负数时，会抛出异常，多次请求为负数抛出异常到达预定的失败率后，服务熔断启动

![image-20201123172842745](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201123172842745.png)

由上图可以看出，11并不是负数，但是因为服务熔断了，也会启用备用方法

# 7、服务监控图形化Dashboard

## 1.新建项目pom依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
        <exclusions>
            <exclusion>
                <groupId>org.junit.vintage</groupId>
                <artifactId>junit-vintage-engine</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
</dependencies>
```

## 2.yml配置

```yml
server:
  port: 9001
hystrix:
  dashboard:
    proxy-stream-allow-list: "*"
```

## 3.在主启动类加注解

```java
@SpringBootApplication
//开启图形化管理界面
@EnableHystrixDashboard
public class CloudConsumerHystrixDashboard9001Application {

    public static void main(String[] args) {
        SpringApplication.run(CloudConsumerHystrixDashboard9001Application.class, args);
    }

}
```

## 4.微服务添加监控依赖配置

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

## 5.微服务配置

在被监控的服务模块新建配置类

加上注解@EnableCircuitBreaker

```java
@Configuration
public class HystrixConfig {

    //    为了服务监控而配置，是个springcloud升级留下的坑
    @Bean
    public ServletRegistrationBean getServlet() {
        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
        registrationBean.setLoadOnStartup(1);
        registrationBean.addUrlMappings("/actuator/hystrix.stream");//访问路径
        registrationBean.setName("hystrix.stream");
        return registrationBean;
    }

}
```

## 6.访问页面

访问localhost:9001/hystrix即可访问主页

![image-20201127173312785](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201127173312785.png)

## 7.监控指定微服务

在监控主页输入要监控的服务地址http://localhost:8001/actuator/hystrix.stream

![image-20201128145250031](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201128145250031.png)

![image-20201128145305544](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201128145305544.png)

