# 1、概述

## 1.简介

提供一种简单有效的方式来对API进行路由，以及提供一些强大的过滤器功能，例如：熔断、限流、重试等等

为了提升性能，Gateway是基于WebFlux框架实现的，Gateway的目标是提供统一的路由方式且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流

## 2.三大概念

1. route（路由）：路由是构建网关的基本模块，它由ID、目标URL、一系列的断言和过滤器组成，如果断言为true则匹配该路由
2. predicate（断言）：开发人员可以匹配HTTP请求的所有内容，如果请求断言与断言相匹配则进行路由
3. Filter（过滤）：使用过滤器，可以在请求被路由前或者之后对请求进行修改

# 2、网关模块搭建

## 1.pom文件

```xml
<dependencies>
    <dependency>
        <groupId>com.he.springcloud</groupId>
        <artifactId>cloud-api-commons</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
                    <version>2.2.2.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
        <exclusions>
            <exclusion>
                <groupId>org.junit.vintage</groupId>
                <artifactId>junit-vintage-engine</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
</dependencies>
```

## 2.yml配置文件

```yml
server:
  port: 9527

spring:
  application:
    name: cloud-gateway

eureka:
  instance:
    hostname: cloud-gateway-service
  client:
    register-with-eureka: true
    fetch-registry: true
    defaultZone: http://eureka7001.com:7001/eureka
```

## 3.在主启动类加注解

加@EnableEurekaClient来将网关模块注册进eureka

```java
@SpringBootApplication
@EnableEurekaClient
public class CloudGatewayGateway9527Application {

    public static void main(String[] args) {
        SpringApplication.run(CloudGatewayGateway9527Application.class, args);
    }

}
```

## 4.在yml配置路由规则

```yml
spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      routes:
        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001          #匹配后提供服务的路由地址
  #        uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**         # 断言，路径相匹配的进行路由
  
        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001          #匹配后提供服务的路由地址
  #        uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
```

## 5.访问测试

可以看到，我们通过访问[localhost:9527/payment/get/31](http://localhost:9527/payment/get/31)与访问[localhost:8001/payment/get/31](http://localhost:8001/payment/get/31)得到的结果是一致的

![image-20201128175332714](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201128175332714.png)

# 3、配置路由的两种方式

## 1.在配置文件yml中配置

同上一步所示

## 2.代码中注入RouteLocator的Bean

### 1.新建配置类

```java
@Configuration
public class GatewayConfig {

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder){
        RouteLocatorBuilder.Builder routes = builder.routes();
//        https://baike.baidu.com/calendar
//        这样访问localhost:9527/calendar会跳转到https://baike.baidu.com/calendar
        routes.route("path_route_he",
                r ->r.path("/calendar")
                        .uri("https://baike.baidu.com/calendar")).build();
        return routes.build();
    }

}
```

路由配置主要步骤

```java
 routes.route("path_route_he",
                r ->r.path("/calendar")
                        .uri("https://baike.baidu.com/calendar")).build();
```

上面这段代码相当于yml配置的

```yml
routes:
        - id: path_route_he     #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: https://baike.baidu.com/calendar          #匹配后提供服务的路由地址
  #        uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            - Path=/calendar         # 断言，路径相匹配的进行路由
```

### 2.访问地址

访问http://localhost:9527/calendar

![image-20201129155333772](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201129155333772.png)

可以看到可以跳转到百度百科的历史上的今天

# 4、通过微服务名称实现动态路由

## 1.开启功能

```yml
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由
          lower-case-service-id: true  #uri的微服务名使用小写
```

## 2.修改uri地址

格式为lb://微服务模块在注册中心的名字，lb 代表从注册中心获取服务

```yml
uri: lb://cloud-payment-service #匹配后提供服务的路由地址
```

## 3.修改后的yml

```yml
spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true     #开启从注册中心动态创建路由的功能，利用微服务名进行路由
          lower-case-service-id: true  #uri的微服务名使用小写
      routes:
        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
#          uri: http://localhost:8001          #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**         # 断言，路径相匹配的进行路由

        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
#          uri: http://localhost:8001          #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
```

## 4.结果

![image-20201129173905907](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201129173905907.png)

# 5、常用Predicate（断言）

## 1.After

在指定时间之后路由生效

```yml
- After=2020-02-21T15:51:37.485+08:00[Asia/Shanghai]
```

时间格式可以通过以下代码获取

```java
ZonedDateTime zbj = ZonedDateTime.now();
```

## 2.Before

在指定时间之前路由生效

```yml
- Before=2020-02-21T15:51:37.485+08:00[Asia/Shanghai]
```

## 3.Between

在指定时间区间生效

```yml
- Between=2020-02-21T15:51:37.485+08:00[Asia/Shanghai],2020-03-21T15:51:37.485+08:00[Asia/Shanghai]
```

## 4.Cookie

Cookie需要2个参数，一个是cookie name，一个是正则表达式，路由规则会通过cookie name与正则表达式去匹配，匹配就会路由，不匹配就不会路由

```yml
- Cookie=username,zzyy
```

如果cookie的username值为zzyy，则会进行路由

## 5.Header

请求头要有某一属性，并且这个属性要符合后面的正则表达式

```yml
- Header=X-Request-Id,-d+
```

## 6.Host

Host接收一组参数，一组匹配的域名列表，通过参数中的主机地址作为匹配规则

```yml
- Host=**.baidu.com,**.hes.cn
```

## 7.Method

匹配请求方法为Get、Post等

```yml
- Method=Get
```

## 8.Path

理解相匹配的进行路由

```yml
- Path=/payment/lb/**
```

## 9.Query

要有指定参数，并且参数符合正则表达式

```yml
- Query=username,\d+
```

# 6、Filter

## 1.Gateway的Filter

### 生命周期：业务逻辑前和业务逻辑后

### 种类：局部和全局

## 2.内置过滤器

### 局部过滤器

![img](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/1829785-20200209212202264-1438140925.png)

![img](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/1829785-20200209212215327-1806642756.png)

### 全局过滤器

![img](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/1829785-20200209212250043-1895422793.png)

## 2.自定义过滤器

### 1.新建接口实现类

要实现GlobalFilter（全局过滤器）或GatewayFilter（局部过滤器）和Ordered接口

```java
@Component
@Slf4j
public class MyLogGatewayFilter implements GlobalFilter, Ordered {

//    处理请求
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("进入MyLogGatewayFilter："+new Date());
        String uname = exchange.getRequest().getQueryParams().getFirst("uname");
        if (uname == null){
            log.info("uname为null，非法用户");
//            设置状态码为NOT_ACCEPTABLE
            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);
//            返回错误信息
            return exchange.getResponse().setComplete();
        }
//        通过过滤器，让下一个过滤器处理请求
        return chain.filter(exchange);
    }

//    过滤器的优先级最高可到2147483647，最低可到-2147483648
    @Override
    public int getOrder() {
        return 0;
    }
}
```

### 2.测试结果

![image-20201201153619891](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201201153619891.png)

当请求符合过滤器时可以正常访问

![image-20201201153702008](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201201153702008.png)

当请求不符合过滤器时访问异常