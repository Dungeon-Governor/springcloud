# 1、概述

## 1.简介

springcloud stream是一个构建消息驱动微服务的框架，目前支持RabbitMQ和Kafka

## 2.作用

屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型

## 3.binder简介

应用程序通过inputs和outputs来与springcloud stream中的binder对象交互，同配置来绑定，而springcloud stream的binder对象负责与消息中间件交互。

## 4.常用API和注解

### API

1. Binder：很方便的连接中间件，屏蔽差异
2. Channel：通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置
3. Source和Sink：Stream自身

### 注解

1. @input：注解标识输入通道，通过该输入通道收到的消息进入应用程序
2. @Output：注解标识输出通道，发布的消息将通过该消息通道离开应用程序
3. @StreamListener：监听队列，用于消费者的队列的消息接收
4. @EnableBinding：将信道Channel和Exchange绑定在一起

# 2、生产者构建

## 1.pom依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.junit.vintage</groupId>
            <artifactId>junit-vintage-engine</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.amqp</groupId>
    <artifactId>spring-rabbit-test</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

## 2.yml配置

```yml
server:
  port: 8801


eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka
  instance:
    lease-renewal-interval-in-seconds: 2  #设置心跳发送间隔
    lease-expiration-duration-in-seconds: 5 #设置超过5s没收到心跳就会删除
    instance-id: send-8801.com  #在信息列表显示的主机名称
    prefer-ip-address: true #访问路径变ip地址

spring:
  application:
    name: cloud-stream-provider
  cloud:
    stream:
      binders: # 在此处配置要绑定的rabbitmq的服务信息；
        defaultRabbit: # 表示定义的名称，用于于binding整合
          type: rabbit # 消息组件类型
          environment: # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
                host: localhost
                port: 5672
                username: guest
                password: guest
      bindings: # 服务的整合处理
        output: # 这个名字是一个通道的名称
          destination: studyExchange # 表示要使用的Exchange名称定义
          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”
          binder: defaultRabbit # 设置要绑定的消息服务的具体设置
```

## 3.主启动类加注解

@EnableEurekaClient

## 4.业务类

### 发送消息接口

```java
public interface MyMessageProvider {

    public String send();

}
```

### 发送消息接口实现类

Source所在包：

import org.springframework.cloud.stream.messaging.Source;

```java
//将信道Channel和Exchange绑定在一起
//定义为消息的推送管道
@EnableBinding(Source.class)
@Slf4j
public class MyMessageProviderImpl implements MyMessageProvider {

//    消息发送管道
    @Resource
    private MessageChannel output;

    @Override
    public String send() {

        String serial = UUID.randomUUID().toString();
        output.send(MessageBuilder.withPayload(serial).build());
        log.info("*****serial："+ serial);
        return null;
    }
}
```

### Controller

```java
@RestController
public class SendMessageController {

    @Resource
    private MyMessageProvider myMessageProvider;

    @GetMapping("/sendMessage")
    public String sendMessage(){
        return myMessageProvider.send();
    }

}
```

## 5.测试

访问[localhost:8801/sendMessage](http://localhost:8801/sendMessage)

![image-20201204154002657](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201204154002657.png)

可以看到信息发送成功

![image-20201204154103260](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201204154103260.png)

可以在rabbitmq管理页面中看到后台 监控流量信息

# 3、消费者搭建

## 1.pom依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.junit.vintage</groupId>
            <artifactId>junit-vintage-engine</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

## 2.yml配置

和生产者基本一致，除了将output改为input

```yml
server:
  port: 8802

eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka
  instance:
    lease-renewal-interval-in-seconds: 2  #设置心跳发送间隔
    lease-expiration-duration-in-seconds: 5 #设置超过5s没收到心跳就会删除
    instance-id: send-8802.com  #在信息列表显示的主机名称
    prefer-ip-address: true #访问路径变ip地址

spring:
  application:
    name: cloud-stream-consumer
  cloud:
    stream:
      binders: # 在此处配置要绑定的rabbitmq的服务信息；
        defaultRabbit: # 表示定义的名称，用于于binding整合
          type: rabbit # 消息组件类型
          environment: # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
                host: localhost
                port: 5672
                username: guest
                password: guest
      bindings: # 服务的整合处理
        input: # 这个名字是一个通道的名称
          destination: studyExchange # 表示要使用的Exchange名称定义
          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”
          binder: defaultRabbit # 设置要绑定的消息服务的具体设置
```

## 3.业务类

```java
@Component
//将信道Channel和Exchange绑定在一起
//定义为消息的接收管道
@EnableBinding(Sink.class)
@Slf4j
public class ReceiveMessageListenerController {

    @Value("${server.port}")
    private String ServerPort;

    @StreamListener(Sink.INPUT)
//    监听队列，用于消费者的队列的消息接收
    public void input(Message<String> message){

        log.info("消费者8802------》接收到消息："+message.getPayload()+"\t port："+ServerPort);

    }

}
```

## 4.测试

访问[localhost:8801/sendMessage](http://localhost:8801/sendMessage)

![image-20201204161209328](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201204161209328.png)

生产者可以看到消息发送出去了

![image-20201204161159954](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201204161159954.png)

客户端也接收到了数据

![image-20201204161243574](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201204161243574.png)

在rabbitmq后台也看到了流量监控的变化

# 4、分组消费和持久化

## 1.按照8802创建8803

## 2.常见问题

### 1.重复消费

![image-20201204171041221](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201204171041221.png)

![image-20201204171052899](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201204171052899.png)

8002和8003都接受到了消息，这样的话在某些场景会产生严重的错误，我们可以用分组的方式来解决问题，在同一个组的消费者是竞争关系，消息只被一个消费者接收，不同组的就会同时收到消息

### 2.消息持久化

 当生产者发送消息之后，如果消费者没有在发送消息的时候起的，这样等消费者启动之后，之前发送的消息也不会被消费，造成了消息的丢失。

## 3.分组解决消息重复消费

修改两个客户端的yml

添加group: heA #分组设置，将两个客户端分为一个组heA

```yml
bindings: # 服务的整合处理
  input: # 这个名字是一个通道的名称
    destination: studyExchange # 表示要使用的Exchange名称定义
    content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”
    binder: defaultRabbit # 设置要绑定的消息服务的具体设置
    group: heA #分组设置
```

![image-20201204172458014](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201204172458014.png)

![image-20201204172533634](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201204172533634.png)

可以在rabbitmq管理页面看到heA分组下有两个消费者

## 4.测试结果

![image-20201204172634876](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201204172634876.png)

可以看到生产者发出了两条消息

![image-20201204172810504](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201204172810504.png)

![image-20201204172817607](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201204172817607.png)

而服务端8802和8803分别只接收到了其中的一条消息，解决了重复消费的问题，组内成员会以轮询的方式进行接收消息

## 5.消息持久化

对客户端进行分组设置，就可以解决消息丢失的问题

![image-20201205100335357](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201205100335357.png)

生产者发出了四条消息

![image-20201205100402471](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201205100402471.png)

消费者8802没有分组，所以重启后没收到

![image-20201205100433217](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201205100433217.png)

消费者8803分组了，所以重启后收到了