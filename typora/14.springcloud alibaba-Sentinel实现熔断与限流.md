# 1、概述

## 1.简介

Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。

Sentinel 具有以下特征:

- **丰富的应用场景**：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。
- **完备的实时监控**：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。
- **广泛的开源生态**：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。
- **完善的 SPI 扩展点**：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。

## 2.主要特征

![Sentinel-features-overview](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/50505538-2c484880-0aaf-11e9-9ffc-cbaaef20be2b.png)

## 3.安装

### 1.下载

下载地址：https://github.com/alibaba/Sentinel/releases

### 2.运行

java -jar sentinel-dashboard-1.7.1.jar

### 3.访问管理界面

localhost:8080，默认账户密码都是sentinel

![image-20201209160254615](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201209160254615.png)

# 2、初始化工程

## 1.新建模块

cloudalibaba-sentinel-service8401

## 2.pom依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-alibaba-sentinel-datasource</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.junit.vintage</groupId>
            <artifactId>junit-vintage-engine</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

## 3.yml文件

```yml
server:
  port: 8401
  
spring:
  application:
    name: cloudalibaba-sentinel-service
  cloud:
    nacos:
      discovery:
#        nacos服务注册中心地址
        server-addr: localhost:8848
    sentinel:
      transport:
#        配置sentinel dashboard地址
        dashboard: localhost:8080
#        默认8719端口，如果该端口被占用，则会依次+1扫描未被占用的端口号
        port: 8719

management:
  endpoints:
    web:
      exposure:
        include: '*'
```

## 4.主启动类加注解

@EnableDiscoveryClient

## 5.业务类

```java
@RestController
@Slf4j
public class FlowLimitController {

    @GetMapping("/testA")
    public String testA(){
        return "*****testA*****";
    }
    @GetMapping("/testB")
    public String testB(){
        return "*****testB*****";
    }

}
```

## 6.启动测试

启动nacos、sentinel和建好的模块

因为sentinel采用的懒加载机制，需要访问一次微服务的服务才能加载微服务监控信息

执行一次http://localhost:8401/testB和http://localhost:8401/testA

![image-20201209160254615](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201209162636601.png)

监控信息加载成功

# 3.流量控制

## 1.流量控制规则

![image-20201209163312660](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201209163312660.png)

新增流控规则界面

1. 资源名：唯一名称，默认请求路径

2. 针对来源：sentinel可以针对调用者进行限流，填写微服务名，默认为default，即不区分来源

3. 阈值类型/单机阈值：

   qps（每秒钟请求时）：当调用该api的qps达到阈值时，进行限流

   线程数：当调用该api的线程数到达阈值时，进行限流

4. 流控模式：

   直接：api达到限流条件时，直接限流

   关联：当关联的资源达到阈值时，就限流自己

   链路：只记录指定链路上的流量，如果流量达到阈值，就进行限流

5. 流控效果

   快速失败：直接失败，抛异常

   Warm Up：根据codeFactor（冷加载因子，默认是3）的值，从阈值/codeFactor，经过预热时长，才到达设置的qps阈值

   排队等待：匀速排队，让请求以匀速的速度通关，阈值类型必须设为qps，否则无效

## 2.OPS直接失败（默认）

![image-20201210100033025](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201210100033025.png)

设置流控规则为每秒请求数最多为1，超过了就会直接请求失败

![image-20201210100237809](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201210100237809.png)

访问数超过阈值，直接失败

## 3.线程数直接失败

![image-20201210100712271](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201210100712271.png)

设置流控规则为每次只能处理一个请求，处理期间其他请求来了就会直接失败

将testA请求设置线程sleep0.8s

![image-20201210101605845](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201210101605845.png)

当请求处理期间其他请求来访问会直接失败

## 4.关联

当关联的资源达到阈值时，就限流自己，比如支付模块达到阈值后，就会限流订单模块

![image-20201210102044383](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201210102044383.png)

将testA与testB进行关联

![image-20201210103748568](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201210103748568.png)

使用postmortem，用20个线程每间隔0.3s就访问一次testB

![image-20201210103913832](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201210103913832.png)

testB的访问达到了阈值，相对应的testA被限流了

## 5.链路

只记录指定链路上的流量，如果流量达到阈值，就进行限流

编写服务类，并调用

```java
@Service
public class TestServiceImpl  implements TestService {
    @Override
//    设置链路资源名
    @SentinelResource("test")
    public String test() {
        return "链路测试";
    }
}
```

```java
@RestController
@Slf4j
public class FlowLimitController {

    @Resource
    private TestService testService;

    @GetMapping("/testA")
    public String testA(){
        return "*****testA*****"+testService.test();
    }
    @GetMapping("/testB")
    public String testB(){
        return "*****testB*****"+testService.test();
    }

}
```

当从某个接口过来的资源达到限流条件时，就开启限流

![image-20201210105636301](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201210105636301.png)

从1.6.3 版本开始，Sentinel Web fifilter默认收敛所有URL的入口context，因此链路限流不生效。 1.7.0 版本开始（对应SCA的2.1.1.RELEASE)，官方在CommonFilter 引入了 WEB_CONTEXT_UNIFY 参数，用于控制是否收敛context。将其配置为 false 即可根据不同的URL 进行链路限流。 SCA 2.1.1.RELEASE之后的版本,可以通过配置spring.cloud.sentinel.web-context-unify=false即可关闭收敛我们当前使用的版本是SpringCloud Alibaba 2.1.0.RELEASE，无法实现链路限流。 

## 6.预热

当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能会把系统压垮，通过预热，可以在一定时间增加到阈值上限，避免系统呗压垮

一开始的阈值从设定阈值除以cloudFactor（默认值为3）开始处理，经过设定的预热时长才会到达设置的阈值

![image-20201211134552669](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201211134552669.png)

对testB进行预热流控，设定阈值为10，预热时间为5s

![预热测试](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/%E9%A2%84%E7%83%AD%E6%B5%8B%E8%AF%95.gif)

## 7.排队等待

让请求匀速排队，以匀速通过，阈值类型必须设为qps，否则无效

![image-20201211144221807](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201211144221807.png)

对testB进行排队等待流控，设置超时时间为20s

![image-20201211144615743](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201211144615743.png)

用postman设置10个线程，每1s就发送一个请求

![排队等待测试](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/%E6%8E%92%E9%98%9F%E7%AD%89%E5%BE%85%E6%B5%8B%E8%AF%95.gif)

# 4、降级规则

## 1.简介

![image-20201211150744141](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201211150744141.png)

1. RT：（平均响应时间，秒级）

   平均响应时间，超出阈值且在时间窗口内通过的请求>=5，两个条件同时满足后触发降级

   时间窗口期过后关闭断路器

   RT最大值4900，超过此阈值的都按4900算

2. 异常比例数（秒级）

   qps>=5且异常比例（秒级统计）超过阈值时，触发降级，时间窗口结束后，关闭降级

3. 异常数（分钟级）

   异常数（分钟统计）超过阈值时，触发降级，时间窗口结束后，关闭降级



sentinel没有半开状态，Hystrix的半开状态是会自动检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常就继续打开断路器不可用

## 2.RT

如果每秒持续进入5个及以上请求，并且平均响应时间超出阈值，那么就会触发降级，断路器打开，当时间窗口结束后，就会关闭降级

![image-20201212080659443](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201212080659443.png)

对testD设置降级规则，阈值为0.2s，时间窗口期为1s

![image-20201212081830149](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201212081830149.png)

用jMeter进行测试，每1s发送10个请求

![RT降级测试](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/RT%E9%99%8D%E7%BA%A7%E6%B5%8B%E8%AF%95.gif)

## 3.异常比例

如果每秒持续进入5个及以上请求，并且每秒异常总数占通过量的比例超过阈值，那么就会触发降级，断路器打开，当时间窗口结束后，就会关闭降级，异常比例阈值范围是[0.0~1.0]，代表0%~100%

![image-20201212084443208](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201212084443208.png)

对testD设置降级规则，阈值为20%，时间窗口期为3s

对testD进行修改，使其异常率为100%

用jMeter进行测试，每1s发送10个请求

![异常比例降级测试](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/%E5%BC%82%E5%B8%B8%E6%AF%94%E4%BE%8B%E9%99%8D%E7%BA%A7%E6%B5%8B%E8%AF%95.gif)

## 4.异常数

当资源近1分钟的异常数目超过阈值之后会进行熔断，因为是监控的近一分钟的情况，所有时间窗口要是小于60秒，那么结束熔断后还有可能再次进入熔断状态，所有时间窗口要大于60秒

![image-20201212093138120](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201212093138120.png)

对testE设置降级规则，阈值为5，时间窗口期为70s

对testE进行修改，使其异常率为100%

![异常数降级测试](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/%E5%BC%82%E5%B8%B8%E6%95%B0%E9%99%8D%E7%BA%A7%E6%B5%8B%E8%AF%95.gif)

# 5、热点KEY规则

## 1.简介

sentinel会利用LRU策略统计最近最常访问的热点参数，结合令牌桶算法进行参数级别的流控

## 2.添加测试方法

```java
    @GetMapping("/testHotKey")
//    设置资源名和兜底方法为deal_testHotKey
    @SentinelResource(value = "testHotKey",blockHandler = "deal_testHotKey")
    public String testHotKey(@RequestParam(value = "p1",required = false) String p1,
                             @RequestParam(value = "p1",required = false) String p2){
        return "*****testHotKey*****";
    }

    public String deal_testHotKey(String p1, String p2, BlockException e){
        return "*****deal_testHotKey*****";
    }
```

## 3.配置热点规则

![image-20201212101016607](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201212101016607.png)

资源名填@SentinelResource设置的value值，参数索引是从0开始的，这里设置的就是参数p1，阈值设置为每秒1个

![热点规则测试](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/%E7%83%AD%E7%82%B9%E8%A7%84%E5%88%99%E6%B5%8B%E8%AF%95.gif)

如果使用热点规则的话，必须要在@SentinelResource设置兜底方法，否则会导致直接显示异常页面

![热点规则异常测试](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/%E7%83%AD%E7%82%B9%E8%A7%84%E5%88%99%E5%BC%82%E5%B8%B8%E6%B5%8B%E8%AF%95.gif)

## 4.参数例外项

当参数是某个期望的特殊值时，就会改变限流规则，例如p1=5时，它的阈值可以是200

![image-20201212103300295](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201212103300295.png)

资源名填@SentinelResource设置的value值，参数索引是从0开始的，这里设置的就是参数p1，阈值设置为每秒1个，当p1的值为5的时候，阈值可以到达200

![热点参数例外项测试](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E4%BE%8B%E5%A4%96%E9%A1%B9%E6%B5%8B%E8%AF%95.gif)

参数类型必须是基本数据类型必须是以下几种

![image-20201212103608878](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201212103608878.png)

## @注意事项

**@SentinelResource设置的blockHandler兜底方法处理的是sentinel控制台配置的违规情况，java运行出错不归它处理**

# 6、系统规则

## 1.说明

sentinel系统自适应限流从整体维度对应用入口流量进行控制结合应用的几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载均衡达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性

## 2.阈值类型

- LOAD（自适应，仅对linux和unix-like机器生效）：用系统的load作为启发指标，进行自适应系统保护，当系统load超过设定的启发值，且系统当前并发线程超过估算的系统容量时才会触发系统保护
- CPU 使用率：当系统cpu使用率超过阀值就会触发系统保护，阈值取值范围是0.0~1.0，比较灵敏
- 平均RT：当单台机器上所有入口流量的平均RT值达到阀值就会触发系统保护，单位是毫秒
- 并发线程数：当单台机器上所有入口流量的并发线程数达到阈值就会触发系统保护
- 入口QPS：当单台机器上所有入口流量的QPS达到入职就会触发系统保护

# 7、@SentinelResource

## 1.修改模块

### 1.增加依赖

```xml
<dependency>
    <groupId>com.he.springcloud</groupId>
    <artifactId>cloud-api-commons</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```

### 2.新增业务类

```java
@RestController
@Slf4j
public class RateLimitController {

    @GetMapping("/byResource")
    @SentinelResource(value = "byResource",blockHandler = "handlerException")
    public CommonResult byResource(){
        return new CommonResult(200,"按资源名称限流访问成功",new Payment(2020L,"serial001"));
    }

    public CommonResult handlerException(BlockException e){
        return new CommonResult(444,e.getClass().getCanonicalName(),"/t服务不可用");
    }

}
```

## 2.自定义限流处理逻辑

业务类方法

```java
    @GetMapping("/rateLimit/customerBlockHandler")
    @SentinelResource(value = "customerBlockHandler",
//            指定兜底方法类
            blockHandlerClass = CustomerBlockHandler.class,
//            指定兜底方法
            blockHandler = "handlerException2")
    public CommonResult customerBlockHandler(){
        return new CommonResult(200,"按自定义逻辑限流访问成功",new Payment(2020L,"serial003"));
    }
```

兜底类

```java
public class CustomerBlockHandler {

//    兜底方法，必须是静态的，并且返回值类型要和被兜底方法一致
    public static CommonResult handlerException(BlockException e){
        return new CommonResult(444,"handlerException------1");
    }
    public static CommonResult handlerException2(BlockException e){
        return new CommonResult(444,"handlerException------2");
    }

}
```

## 3.测试

对customerBlockHandler进行限流处理，设置qps阈值为1

![自定义限流处理类测试](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%99%90%E6%B5%81%E5%A4%84%E7%90%86%E7%B1%BB%E6%B5%8B%E8%AF%95.gif)

# 8、服务熔断

## 1.环境配置

### 1.服务提供者模块

#### 1.pom依赖

```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.1.10</version>
</dependency>
<!--mysql-connector-java-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
<!--jdbc-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>com.he.springcloud</groupId>
    <artifactId>cloud-api-commons</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.junit.vintage</groupId>
            <artifactId>junit-vintage-engine</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

#### 2.yml

```yml
server:
  port: 9003

spring:
  application:
    name: nacos-payment-provider
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型
    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包
    url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&characterEncoding=utf-8&useSSL=false
    username: root
    password: root

management:
  endpoints:
    web:
      exposure:
        include: '*'
        
mybatis:
  mapperLocations: classpath:mapper/*.xml
  type-aliases-package: com.he.springcloud.entities    # 所有Entity别名类所在包
```

#### 3.业务类

连接数据库，然后下面是Controller方法

```java
@RestController
@Slf4j
public class PaymentController {

    @Value("${server.port}")
    private String serverPort;

    @Resource
    private PaymentService paymentService;

    @GetMapping("/paymentSQL/{id}")
    public CommonResult<Payment> paymentSQL(@PathVariable("id") Long id){
        Payment payment = paymentService.getPayment(id);
        CommonResult<Payment> result = new CommonResult(200,"serverPort："+serverPort,payment);
        return result;
    }

}
```

#### 4.按照9003创建一个9004

### 2.服务消费者模块

#### 1.pom依赖

```xml
<dependency>
    <groupId>com.he.springcloud</groupId>
    <artifactId>cloud-api-commons</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.junit.vintage</groupId>
            <artifactId>junit-vintage-engine</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

#### 2.yml配置

```yml
server:
  port: 84

spring:
  application:
    name: nacos-order-consumer
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
    sentinel:
      transport:
        dashboard: localhost:8080
        port: 8719

service-url:
  nacos-user-service: http://nacos-payment-provider
```

#### 3.业务类

```java
@Configuration
public class ApplicationContextConfig {

    @Bean
    @LoadBalanced
    public RestTemplate getRestTemplate(){
        return new RestTemplate();
    }

}
```

```java
@RestController
@Slf4j
public class CircleBreakerController {

    @Value("${service-url.nacos-user-service}")
    private String serverUrl;

    @Resource
    private RestTemplate restTemplate;

    @GetMapping("/consumer/fallback/{id}")
    @SentinelResource(value = "fallback")
    public CommonResult<Payment> fallback(@PathVariable("id") Long id){
        CommonResult result = restTemplate.getForObject(serverUrl + "/paymentSQL/" + id, CommonResult.class, id);
        if(id == 4){
            throw new IllegalArgumentException("非法参数异常");
        }else if(result.getData() == null){
            throw new NullPointerException("该id没有相应记录，空指针异常");
        }
        return result;
    }

}
```

## 2.服务熔断配置fallback

```java
public CommonResult<Payment> handlerFallBack(@PathVariable Long id,Throwable e){
    Payment payment = new Payment(id, null);
    CommonResult<Payment> result = new CommonResult(444,"兜底方法handlerFallBack，异常信息："+e.getMessage(),payment);
    return result;
}
```

![服务熔断配置fallback测试](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E9%85%8D%E7%BD%AEfallback%E6%B5%8B%E8%AF%95.gif)

## 3.服务熔断配置blockHandler

```java
    @GetMapping("/consumer/fallback/{id}")
    @SentinelResource(value = "fallback",
//            fallback只负责业务异常
            fallback = "handlerFallBack",
//            blockHandler只负责sentinel控制台配置违规
            blockHandler = "blockHandler")
    public CommonResult<Payment> fallback(@PathVariable("id") Long id){
        CommonResult result = restTemplate.getForObject(serverUrl + "/paymentSQL/" + id, CommonResult.class, id);
        if(id == 4){
            throw new IllegalArgumentException("非法参数异常");
        }else if(result.getData() == null){
            throw new NullPointerException("该id没有相应记录，空指针异常");
        }
        return result;
    }

    public CommonResult<Payment> handlerFallBack(@PathVariable Long id,Throwable e){
        Payment payment = new Payment(id, null);
        CommonResult<Payment> result = new CommonResult(444,"兜底方法handlerFallBack，异常信息："+e.getMessage(),payment);
        return result;
    }
    public CommonResult<Payment> blockHandler(@PathVariable Long id, BlockException e){
        Payment payment = new Payment(id, null);
        CommonResult<Payment> result = new CommonResult(445,"blockHandler限流，无此流水：BlockException信息："+e.getMessage(),payment);
        return result;
    }
```

## 4.测试

增加降级规则，每秒异常数大于等于2就会触发服务降级

![服务熔断配置fallback和blockHandler测试](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E9%85%8D%E7%BD%AEfallback%E5%92%8CblockHandler%E6%B5%8B%E8%AF%95.gif)

## 5.exceptionsToIgnore

```java
//            设置fallback不处理IllegalArgumentException异常
            exceptionsToIgnore = {IllegalArgumentException.class}
```

![exceptionsToIgnore测试](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/exceptionsToIgnore%E6%B5%8B%E8%AF%95.gif)

## 6.整合openFeign

### 1.修改消费端yml

激活sentinel对feign的支持

```yml
#激活sentinel对feign的支持
feign:
  sentinel:
    enabled: true
```

### 2.主启动类添加注解

@EnableFeignClients

### 3. 编写服务接口

```java
@FeignClient(value = "nacos-payment-provider",fallback = PaymentFallbackService.class)
public interface PaymentService {

    @GetMapping("/paymentSQL/{id}")
    public CommonResult<Payment> paymentSQL(@PathVariable("id") Long id);

}
```

### 4.编写服务接口实现类

```java
@Component
public class PaymentFallbackService implements PaymentService{
    @Override
    public CommonResult<Payment> paymentSQL(Long id) {
        return new CommonResult<Payment>(444,"服务降级返回，fallbcak",new Payment(id,"error"));
    }
}
```

### 5.controller方法

```java
@Resource
private PaymentService paymentService;

@GetMapping("/consumer/paymentSQL/{id}")
public CommonResult<Payment> paymentSQL(@PathVariable("id") Long id){
    return paymentService.paymentSQL(id);
}
```

### 6.测试

![整合openFeign](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/%E6%95%B4%E5%90%88openFeign.gif)

# 9、规则持久化

## 1.实现方法

将限流规则持久化进nacos保存，只要刷新8401某个rest地址，sentinel控制台的限流规则就能看到，只要nacos里面的配置不删除，针对8401的流控规则就持续有效

## 2.引入pom

```xml
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-datasource-nacos</artifactId>
</dependency>
```

## 3.修改yml

添加nacos数据源配置

```yml
datasource:
  ds1: #名称，随意
    nacos:
      server-addr: localhost:8848 #sentinel地址
      dataId: cloudalibaba-sentinel-service #nacos里面配置文件的dataid
      groupId: DEFAULT_GROUP #nacos里面配置文件的groupid
      data-type: json #nacos里面配置文件的类型
      rule-type: flow
```

## 4.在nacos添加配置文件

![image-20201214164830912](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201214164830912.png)

其中，DataId填上面yml配置文件中的dataId，group对应groupId，配置内容格式为json

```json
[
    {
        "resource":"/byResource",	//资源名
        "limitApp":"default",	//针对来源
        "grade":1,	//阈值类型，0代表线程数，1代表QPS
        "count":1,	//单机阈值
        "strategy":0,	//流控模式，0代表直接，1代表关联，2代表链路
        "controlBehavior":0,	//流控效果，0代表快速失败，1代表Warm Up，2代表排队等待
        "clusterMode":false	  //是否集群
    }
]
```

## 5.测试

这样当sentinel启动后，访问相应资源名请求后，就会自动读取nacos中的配置信息

![image-20201214165313870](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201214165313870.png)

读取到的资源信息