# 1、Ribbon概念

Spring Cloud Ribbon是一套客户端负载均衡额工具，主要功能是提供客户端的软件负载均衡算法和服务调用。

## 负载均衡

简单说就是将用户的请求平摊到多个服务上，从而达到系统的高可用

## Ribbon工作步骤

1. 现根据eurekaserver，优先选择在同一个区域内负载较少的server
2. 再根据用户指定的策略，从server取到的服务注册列表中选择一个地址，其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权

## Eureka已经集成Ribbon了，不需要再次单独引入Ribbon

# 2、RestTemplate

## getForObject方法

返回对象为响应体中数据转化成的对象，基本上可以理解为json

## getForEntity方法

返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等，响应体可以用restTemplate.postForEntity().getBody();获得。



在这方面post同get

# 3、核心组件IRule

根据特定算法从服务列表中选取一个要访问的服务

## IRule几个实现类

1. RoundRobinRule：轮询
2. RandomRule：随机
3. RetryRule先按照轮询的策略获取服务，如果获取的服务失败，则在指定时间内会进行重试，获得可用服务
4. WeightedResponseTimeRule：对轮询的扩展，响应速度越快的实例选择权重越大，然后选择一个并发量最小的服务
5. BestAvailableRule：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务
6. AvailabilityFilteringRule：先过滤掉故障实例，在选择并发较小的实例
7. ZoneAvoidanceRule：默认规则，符合判断server所在区域的性能和server的可用性服务器

# 4、通过修改客户端来实现负载规则替换



## 1.新建package

因为新建的规则类不能和springboot主程序类同包，所以应该在springboot主程序类的上级目录里建包，如com.he.myrule

## 2.新建规则类

需要修改成什么样的负载规则，就返回什么样的IRule的实现类

```java
@Configuration
public class MyselfRule {
    @Bean
    public IRule MyRule(){
//        将负载规则改为随机
        return new RandomRule();
    }

}
```

## 3.在主启动类上加注解

加@RibbonClient(name = "CLOUD-PAYMENT-SERVICE",configuration = MyselfRule.class)注解，name属性的值代表访问的服务模块，configuration 代表访问name所指的服务时使用的负载规则

```java
//标记自己为EurekaClient端
@EnableEurekaClient
//访问CLOUD-PAYMENT-SERVICE模块时，使用MyselfRule中自定义的负载规则
@RibbonClient(name = "CLOUD-PAYMENT-SERVICE",configuration = MyselfRule.class)
@SpringBootApplication
public class OrderMain80 {

    public static void main(String[] args) {
        SpringApplication.run(OrderMain80.class,args);
    }

}
```

# 5、自定义负载规则

## 1.轮询算法的基本原理

rest接口第几次请求 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始

例：

rest接口第1次请求 % 2（服务器集群总数量） = 1（实际调用服务器位置下标）

rest接口第2次请求 % 2（服务器集群总数量） = 0（实际调用服务器位置下标）

rest接口第3次请求 % 2（服务器集群总数量） = 1（实际调用服务器位置下标）

rest接口第4次请求 % 2（服务器集群总数量） = 0（实际调用服务器位置下标）

rest接口第5次请求 % 2（服务器集群总数量） = 1（实际调用服务器位置下标）

如此类推。。。。。。。

 