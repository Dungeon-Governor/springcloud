# 1、概述

## 1.简介

Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务

## 2.分布式事务处理过程

### ID+三组件模型

Transaction ID XID：全局唯一的事务ID

TC：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交和回滚

TM：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议

RM：控制分支事务，负责分支注册、状态汇报并接收事务协调器的指令，驱动分支事务

### 处理过程

![img](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/TB1rDpkJAvoK1RjSZPfXXXPKFXa-794-478.png)

1. TM向TC申请开一个全局事务，全局事务创建成功并生成一个全局唯一的XID
2. XID在微服务调用链路的上下文中传播
3. RM向TC注册分支事务，将其纳入对应全局事务的管辖
4. TM向TC发起针对XID的全局提交或回滚协议
5. TC调度XID下管辖的全部分支事务完成提交或回滚请求

## 3.下载安装

### 下载地址：https://github.com/seata/seata/releases

1.0.0是官方推荐版本

### 修改file.conf文件

```
##service模块
service {
  #transaction service group mapping
##自定义事务组名
  vgroupMapping.my_test_tx_group = "alibaba_tx_group"
  #only support when registry.type=file, please don't set multiple addresses
  default.grouplist = "127.0.0.1:8091"
  #disable seata
  disableGlobalTransaction = false
}

## transaction log store, only used in seata-server
##事务存储模块
store {
  ## store mode: file、db
##将存储模式改为数据库db
  mode = "db"

  ## file store property
  file {
    ## store location dir
    dir = "sessionStore"
  }

  ## database store property
  db {
    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.
    datasource = "dbcp"
    ## mysql/oracle/h2/oceanbase etc.
    db-type = "mysql"
##修改数据库相关配置
    driver-class-name = "com.mysql.cj.jdbc.Driver"
        url = "jdbc:mysql://localhost:3306/seata?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=false"
    user = "root"
    password = "root"
  }
}
```

### 新建seata库

执行db_store.sql

```sql
-- the table to store GlobalSession data
drop table if exists `global_table`;
create table `global_table` (
  `xid` varchar(128)  not null,
  `transaction_id` bigint,
  `status` tinyint not null,
  `application_id` varchar(32),
  `transaction_service_group` varchar(32),
  `transaction_name` varchar(64),
  `timeout` int,
  `begin_time` bigint,
  `application_data` varchar(2000),
  `gmt_create` datetime,
  `gmt_modified` datetime,
  primary key (`xid`),
  key `idx_gmt_modified_status` (`gmt_modified`, `status`),
  key `idx_transaction_id` (`transaction_id`)
);

-- the table to store BranchSession data
drop table if exists `branch_table`;
create table `branch_table` (
  `branch_id` bigint not null,
  `xid` varchar(128) not null,
  `transaction_id` bigint ,
  `resource_group_id` varchar(32),
  `resource_id` varchar(256) ,
  `lock_key` varchar(128) ,
  `branch_type` varchar(8) ,
  `status` tinyint,
  `client_id` varchar(64),
  `application_data` varchar(2000),
  `gmt_create` datetime,
  `gmt_modified` datetime,
  primary key (`branch_id`),
  key `idx_xid` (`xid`)
);

-- the table to store lock data
drop table if exists `lock_table`;
create table `lock_table` (
  `row_key` varchar(128) not null,
  `xid` varchar(96),
  `transaction_id` long ,
  `branch_id` long,
  `resource_id` varchar(256) ,
  `table_name` varchar(32) ,
  `pk` varchar(32) ,
  `gmt_create` datetime ,
  `gmt_modified` datetime,
  primary key(`row_key`)
);

```

### 注意

因为seata1.2.0才开始支持mysql8，所有需要将lib库中的链接驱动换成mysql8的

自从1.1.0之后，vgroup_mapping改成vgroupMapping了，我们需要手动把file.conf中的vgroup_mapping改成vgroupMapping

### 修改registry.conf文件

```
#指定注册中心
registry {
  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa
  type = "nacos"

  nacos {
#nacos注册中心地址
    serverAddr = "localhost:8848"
    namespace = ""
    cluster = "default"
  }
```

## 4.运行

先运行nacos，在运行seata

# 2、订单、库存、账户业务数据库的准备

## 1.业务流程说明

创建三个服务，订单、库存、账户服务

用户下单时，会在订单服务创建一个订单，然后通过远程调用库存服务来空间下单商品的库存，再通过远程调用账户服务来扣减用户账户里的余额，最后在订单服务中修改订单状态为已完成

## 2.创建业务数据库

### seata_order库

```sql
DROP TABLE IF EXISTS `t_order`;
CREATE TABLE `t_order`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(11) NULL DEFAULT NULL,
  `product_id` bigint(11) NULL DEFAULT NULL,
  `count` int(11) NULL DEFAULT NULL,
  `money` decimal(11, 0) NULL DEFAULT NULL,
  `status` int(1) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

SET FOREIGN_KEY_CHECKS = 1;
```

### seata_storage库

```sql
DROP TABLE IF EXISTS `t_storage`;
CREATE TABLE `t_storage`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `product_id` bigint(11) NULL DEFAULT NULL,
  `total` int(11) NULL DEFAULT NULL,
  `used` int(11) NULL DEFAULT NULL,
  `residue` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_storage
-- ----------------------------
INSERT INTO `t_storage` VALUES (1, 1, 100, 0, 100);

SET FOREIGN_KEY_CHECKS = 1;
```

### seata_account库

```sql
DROP TABLE IF EXISTS `t_account`;
CREATE TABLE `t_account`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(11) NULL DEFAULT NULL,
  `total` decimal(10, 0) NULL DEFAULT NULL,
  `used` decimal(10, 0) NULL DEFAULT NULL,
  `residue` decimal(10, 0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

SET FOREIGN_KEY_CHECKS = 1;
```

## 3.创建回滚日志表

运行db_undo_log.sql，这三个库里都要有这个表

```sql
CREATE TABLE `undo_log` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `branch_id` bigint(20) NOT NULL,
  `xid` varchar(100) NOT NULL,
  `context` varchar(128) NOT NULL,
  `rollback_info` longblob NOT NULL,
  `log_status` int(11) NOT NULL,
  `log_created` datetime NOT NULL,
  `log_modified` datetime NOT NULL,
  `ext` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

# 3、订单、库存、账户业务微服务的准备

## 1.业务需求

下订单-》减库存-》减余额-》改订单状态

## 2.订单模块

### 1.pom依赖

```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>1.3.0</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.1.10</version>
</dependency>
<!--mysql-connector-java-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.20</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
    <exclusions>
        <exclusion>
            <groupId>io.seata</groupId>
            <artifactId>seata-all</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>io.seata</groupId>
    <artifactId>seata-all</artifactId>
    <version>1.1.0</version>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.junit.vintage</groupId>
            <artifactId>junit-vintage-engine</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

### 2.yml配置

```yml
server:
  port: 2001

spring:
  application:
    name: seata-order-service
  cloud:
    alibaba:
      seata:
#        自定义事务组的名称，要和file.conf中的一致
        tx-service-group: alibaba_tx_group
    nacos:
      discovery:
        server-addr: localhost:8848
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型
    driver-class-name: com.mysql.cj.jdbc.Driver            # mysql驱动包
    url: jdbc:mysql://localhost:3306/seata_order?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=false
    username: root
    password: root

feign:
  hystrix:
    enabled: false
logging:
  level:
    io:
      seata: info

mybatis:
  mapper-locations: classpath:mapper/*.xml
```

### 3.file.conf和registry.conf

vgroup_mapping.my_test_tx_group修改成vgroup_mapping.alibaba_tx_group = "default"，剩下的直接复制file.conf

```
##service模块
service {
  #transaction service group mapping
##自定义事务组名
  vgroupMapping.alibaba_tx_group = "default"
  #only support when registry.type=file, please don't set multiple addresses
  default.grouplist = "127.0.0.1:8091"
  #disable seata
  disableGlobalTransaction = false
}

## transaction log store, only used in seata-server
##事务存储模块
store {
  ## store mode: file、db
##将存储模式改为数据库db
  mode = "db"

  ## file store property
  file {
    ## store location dir
    dir = "sessionStore"
  }

  ## database store property
  db {
    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.
    datasource = "dbcp"
    ## mysql/oracle/h2/oceanbase etc.
    db-type = "mysql"
##修改数据库相关配置
    driver-class-name = "com.mysql.cj.jdbc.Driver"
        url = "jdbc:mysql://localhost:3306/seata?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=false"
    user = "root"
    password = "root"
  }
}
```

直接复制registry.conf

```
#指定注册中心
registry {
  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa
  type = "nacos"

  nacos {
#nacos注册中心地址
    serverAddr = "localhost:8848"
    namespace = ""
    cluster = "default"
  }
  eureka {
    serviceUrl = "http://localhost:8761/eureka"
    application = "default"
    weight = "1"
  }
  redis {
    serverAddr = "localhost:6379"
    db = "0"
  }
  zk {
    cluster = "default"
    serverAddr = "127.0.0.1:2181"
    session.timeout = 6000
    connect.timeout = 2000
  }
  consul {
    cluster = "default"
    serverAddr = "127.0.0.1:8500"
  }
  etcd3 {
    cluster = "default"
    serverAddr = "http://localhost:2379"
  }
  sofa {
    serverAddr = "127.0.0.1:9603"
    application = "default"
    region = "DEFAULT_ZONE"
    datacenter = "DefaultDataCenter"
    cluster = "default"
    group = "SEATA_GROUP"
    addressWaitTime = "3000"
  }
  file {
    name = "file.conf"
  }
}

config {
  # file、nacos 、apollo、zk、consul、etcd3
  type = "file"

  nacos {
    serverAddr = "localhost"
    namespace = ""
  }
  consul {
    serverAddr = "127.0.0.1:8500"
  }
  apollo {
    app.id = "seata-server"
    apollo.meta = "http://192.168.1.204:8801"
  }
  zk {
    serverAddr = "127.0.0.1:2181"
    session.timeout = 6000
    connect.timeout = 2000
  }
  etcd3 {
    serverAddr = "http://localhost:2379"
  }
  file {
    name = "file.conf"
  }
}

```

### 4.domain

CommonResult

```java
//自动为所有字段添加@ToString, @EqualsAndHashCode, @Getter方法，为非final字段添加@Setter,和@RequiredArgsConstructor!
@Data
//自动生成全参数构造函数。
@AllArgsConstructor
//自动生成无参数构造函数。
@NoArgsConstructor
public class CommonResult<T> {

    //    状态码
    private Integer code;

    //     信息
    private String message;

    //     传递对象
    private T data;

    public CommonResult(Integer code, String message){
        this(code,message,null);
    }

}
```

Order

```java
//自动为所有字段添加@ToString, @EqualsAndHashCode, @Getter方法，为非final字段添加@Setter,和@RequiredArgsConstructor!
@Data
//自动生成全参数构造函数。
@AllArgsConstructor
//自动生成无参数构造函数。
@NoArgsConstructor
public class Order {

    private Long id;
    private Long userId;
    private Long productId;
    private Integer count;
    private BigDecimal money;
    private Integer status;

}
```

### 5.dao接口及实现

OrderDao

```java
@Mapper
public interface OrderDao {

//    新建订单
    void create(Order order);
//    修改订单状态，将status从0改成1
    void update(@Param("userId")Long userId,@Param("status")Integer status);

}
```

OrderMapper.xml

```xml
<resultMap id="BaseResultMap" type="com.he.springcloud.dao.OrderDao">
    <id column="id" jdbcType="BIGINT" property="id"></id>
    <result column="user_id" property="userId" jdbcType="BIGINT"></result>
    <result column="product_id" property="productId" jdbcType="BIGINT"></result>
    <result column="count" property="count" jdbcType="INTEGER"></result>
    <result column="money" property="money" jdbcType="DECIMAL"></result>
    <result column="status" property="status" jdbcType="INTEGER"></result>
</resultMap>

<insert id="create">
    insert into t_order (id, user_id, product_id, count, money, status) values (null,#{userId},#{productId},#{count},#{money},0);
</insert>

<update id="update" >
    update t_order set status = 1 where user_id = #{userId} and status = #{status};
</update>
```

### 6.service接口及实现

OrderService

```java
public interface OrderService {

    void create(Order order);

}
```

OrderServiceImpl

```java
@Service
@Slf4j
public class OrderServiceImpl implements OrderService {

    @Resource
    private OrderDao orderDao;
    @Resource
    private AccountService accountService;
    @Resource
    private StorageService storageService;


    @Override
    public void create(Order order) {

        log.info("----->开始新建订单");
        orderDao.create(order);

        log.info("----->订单为服务开始调用库存，做扣减");
        storageService.decrease(order.getProductId(),order.getCount());
        log.info("----->订单为服务开始调用库存，扣减完成");

        log.info("----->订单为服务开始调用账户，做扣减");
        accountService.decrease(order.getUserId(),order.getMoney());
        log.info("----->订单为服务开始调用账户，扣减完成");

        log.info("----->修改订单状态开始");
        orderDao.update(order.getId(),0);
        log.info("----->修改订单状态完成");

        log.info("----->下订单结束");

    }
}
```

AccountService

```java
@FeignClient("seata-account-service")
public interface AccountService {

    @PostMapping("/account/decrease")
    CommonResult decrease(@RequestParam("userId")Long userId, @RequestParam("money") BigDecimal money);

}
```

StorageService

```java
@FeignClient("seata-storage-service")
public interface StorageService {

    @PostMapping("/storage/decrease")
    CommonResult decrease(@RequestParam("productId")Long productId,@RequestParam("count") Integer count);

}
```

### 7.controller

```java
@RestController
@Slf4j
public class OrderController {

    @Resource
    private OrderService orderService;

//    因为这个OrderController是暴露给用户使用的，不能用post，真正创建是在StorageService，那里使用的post
    @GetMapping("/order/create")
    public CommonResult<Order> create(Order order){
        orderService.create(order);
        return new CommonResult<Order>(200,"订单创建成功");
    }

}
```

### 8.一些配置类

MyBatisConfig

```java
@Configuration
@MapperScan({"com.he.springcloud.dao"})
public class MyBatisConfig {
}
```

DataSourceProxyConfig

```java
//使用Seata对数据源进行代理
@Configuration
public class DataSourceProxyConfig {

    @Value("${mybatis.mapper-locations}")
    private String mapperLocations;

    @Bean
    @ConfigurationProperties(prefix = "spring.datasource")
    public DataSource druidDataSource(){
        return new DruidDataSource();
    }

    @Bean
    public DataSourceProxy dataSourceProxy(DataSource dataSource) {
        return new DataSourceProxy(dataSource);
    }

    @Bean
    public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception {
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSourceProxy);
        sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations));
        sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory());
        return sqlSessionFactoryBean.getObject();
    }

}
```

### 9.主启动类的注解

```java
//取消数据源的自动创建
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
@EnableDiscoveryClient
@EnableFeignClients
```

## 2.其他模块

基本和订单模块一致

注意controller的方法加的注解是@RequestMapping，否则feign会报错

## 3.测试

http://localhost:2001/order/create?userId=1&ProductId=1&count=10&money=100

发送请求创建订单

![image-20201226105231423](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201226105231423.png)

请求成功

![image-20201226110905652](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201226110905652.png)

可以看到数值发生了变化

# 3、@GlobalTransactional

## 1.有异常，没有@GlobalTransactional

### 1.在账户模块添加超时

```java
    @Override
    public void decrease(Long userId, BigDecimal money) {
        log.info("----->扣减账户余额开始");
//        模拟超时20s
        try {
            TimeUnit.SECONDS.sleep(20);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        accountDao.decrease(userId, money);
        log.info("----->扣减账户余额完成");
    }
```

### 2.发送请求创建订单

http://localhost:2001/order/create?userId=1&ProductId=1&count=10&money=100

![image-20201227092602195](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201227092602195.png)

发现报错了

![image-20201227092722217](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201227092722217.png)

查看数据库，发现订单状态是未完成，但是钱已经扣了，并且由于feign的重试机制，账户余额还会被多次扣减

## 2.有异常，添加@GlobalTransactional

### 1.添加注解

```java
    @Override
//    name是事务名，可以随意命名，rollbackFor是当出现某个异常时回滚事务
    @GlobalTransactional(name = "he-create-order",rollbackFor = Exception.class)
    public void decrease(Long userId, BigDecimal money) {
        log.info("----->扣减账户余额开始");
//        模拟超时20s
        try {
            TimeUnit.SECONDS.sleep(20);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        accountDao.decrease(userId, money);
        log.info("----->扣减账户余额完成");
    }
```

### 2.发送请求创建订单

![image-20201227094318161](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201227094318161.png)

发现请求报错了

![image-20201227094347925](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201227094347925.png)

再观察数据库，发现没有发生变化，证明事务已经回滚了

# 4、补充

## 执行流程

1. TM开启分布式事务（TM向TC注册全局事务记录）
2. 按业务场景，编排数据库、服务等事务内资源（RM向TC汇报资源准备状态）
3. TM接收分布式事务，事务一阶段结束（TM通知TC提交/回滚分布式事务）
4. TC汇总事务信息，决定分布式事务是提交还是回滚
5. TC通知所有RM提交/回滚资源，事务二阶段结束