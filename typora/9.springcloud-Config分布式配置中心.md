# 1、概述

## 1.简介

springcloud config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置

## 2.概念

### 服务端

服务端也称为分布式配置中心，是一个独立的微服务应用，用来连接服务器并未客户端提供获取配置信息

### 客户端

客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。配置服务器默认采用git来存储配置信息，也可以连接github

# 2、服务端配置

## 1.新建配置文件仓库并克隆到本地

## 2.新建服务端模块

### 1.pom依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-config-server</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.junit.vintage</groupId>
            <artifactId>junit-vintage-engine</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

### 2.配置文件

```yml
server:
  port: 3344
spring:
  application:
    name: cloud-config-center
  cloud:
    config:
      server:
        git:
#          仓库地址
          uri: https://github.com/Dungeon-Governor/springcloud-config.git
#          搜索目录
          search-paths:
            - springcloud-config
#          读取分支
          label: master
#          username: 992374727@qq.com
#          password: Heruijie2010
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka
```

### 3.在主启动类加注解

加上@EnableConfigServer将微服务标注为配置中心服务端

### 4.修改host文件增加映射

```
127.0.0.1     config3344.com
```

## 3.测试获取配置内容

访问[config3344.com:3344/master/config-dev.yml](http://config3344.com:3344/master/config-dev.yml)

![image-20201201172344752](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201201172344752.png)

可以看到可以读取到指定配置文件内容

## 4.配置读取规则

### /{label}/{application}-{profile}.yml

http://config3344.com:3344/master/config-dev.yml

### /{application}-{profile}.yml

http://config3344.com:3344/config-dev.yml

默认会选择服务端配置文件中的默认分支，读取配置文件

### /{application}/{profile}[/{label}]

http://config3344.com:3344/config/dev/master

读取到的是一串json串

# 3、客户端配置

## 1.pom依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-config</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.junit.vintage</groupId>
            <artifactId>junit-vintage-engine</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

## 2.新建bootstrap.yml

bootstrap.yml是系统级的配置文件，比application.yml用户级配置文件优先级高

```yml
server:
  port: 3355
spring:
  application:
    name: config-client
  cloud:
    config:
      label: master  #分支名称
      name: config  #配置文件名称
      profile: dev  #读取配置文件的后缀名称
#      上面三个一起就是读取master分支下的config-dev.yml文件
      uri: http://localhost:3344  #配置中心地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka
```

客户端就会通过服务端读取git中的配置文件

## 3.在主启动类加注解

在主启动类加注解@EnableEurekaClient来注册进eureka

## 4.编写业务类

```java
@RestController
public class ConfigClientController {

    @Value("${config.info}")
    private String configInfo;

    @GetMapping("/configInfo")
    public String getConfigInfo(){
        return configInfo;
    }

}
```

## 5.测试

![image-20201202145717493](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201202145717493.png)

服务端读取到的信息

![image-20201202145734177](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201202145734177.png)

客户端根据配置文件从服务端读取到的信息

# 4、动态刷新

## 1.为什么要动态刷新

若修改了github的配置文件信息，服务端能及时动态的读取到更改之后的配置文件，但是客户端不能通过服务端读取到更改后的配置信息，必须要重启客户端才可以读取到更改之后的配置文件

## 2.引入actuator依赖

```yml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

## 3.修改配置文件暴露监控端点

增加以下配置来暴露所有的监控端点

```yml
#暴露所有的监控端点
management:
  endpoints:
    web:
      exposure:
        include: "*"
```

## 4.在业务类添加注解

在业务类添加注解@RefreshScope来开启动态刷新功能

```java
//开启动态刷新功能
@RefreshScope
```

## 5.测试结果

![image-20201202153522929](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201202153522929.png)可以 看到修改之后，服务端读取到的版本号为8

![image-20201202153601285](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201202153601285.png)

但是客户端读取到的版本号还是7

## 6.发送post请求刷新

其实配置是实现了动态刷新的，但是需要再手动发送一个post请求才能 刷新成功

发送这个请求即可localhost:3355/actuator/refresh

![image-20201202154832181](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201202154832181.png)

发送post刷新请求

![image-20201202154813048](https://raw.githubusercontent.com/Dungeon-Governor/images/master/img/image-20201202154813048.png)

可以看到刷新成功